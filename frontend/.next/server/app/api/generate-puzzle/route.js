/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/generate-puzzle/route";
exports.ids = ["app/api/generate-puzzle/route"];
exports.modules = {

/***/ "(rsc)/./app/api/generate-puzzle/route.js":
/*!******************************************!*\
  !*** ./app/api/generate-puzzle/route.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   POST: () => (/* binding */ POST)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n\n// Add your puzzle logic functions here (buildIndexedLetterMap, etc.)\nasync function POST(req) {\n    const { qnaList } = await req.json();\n    if (!Array.isArray(qnaList) || qnaList.length === 0) {\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            grid: [],\n            placedWords: []\n        }, {\n            status: 200\n        });\n    }\n    const words = qnaList.map((q)=>q.answer.toUpperCase());\n    // Insert your buildIndexedLetterMap, generateIndexedConnections, clusterWordsFromConnections, etc.\n    // Then use them here to generate your puzzle\n    // üß† Build indexed letter map function (new!)\n    function buildIndexedLetterMap(words) {\n        const map = {};\n        for (const word of words){\n            for(let i = 0; i < word.length; i++){\n                const letter = word[i];\n                if (!map[letter]) map[letter] = [];\n                map[letter].push({\n                    word,\n                    index: i\n                });\n            }\n        }\n        return map;\n    }\n    // üîó Build indexed connections from the indexed map\n    function generateIndexedConnections(indexedLetterMap) {\n        const connections = [];\n        for (const [letter, entries] of Object.entries(indexedLetterMap)){\n            for(let i = 0; i < entries.length; i++){\n                for(let j = 0; j < entries.length; j++){\n                    if (i === j) continue;\n                    const from = entries[i];\n                    const to = entries[j];\n                    if (from.word === to.word) continue; // ‚ùå skip same word\n                    connections.push({\n                        from: from.word,\n                        to: to.word,\n                        via: letter,\n                        fromIndex: from.index,\n                        toIndex: to.index\n                    });\n                }\n            }\n        }\n        return connections;\n    }\n    function clusterWordsFromConnections(words, connections) {\n        const graph = {};\n        for (const word of words){\n            graph[word] = new Set();\n        }\n        for (const conn of connections){\n            graph[conn.from].add(conn.to);\n            graph[conn.to].add(conn.from); // bi-directional\n        }\n        const visited = new Set();\n        const clusters = [];\n        for (const word of words){\n            if (visited.has(word)) continue;\n            const cluster = new Set();\n            const queue = [\n                word\n            ];\n            while(queue.length){\n                const current = queue.pop();\n                if (visited.has(current)) continue;\n                visited.add(current);\n                cluster.add(current);\n                for (const neighbor of graph[current]){\n                    if (!visited.has(neighbor)) {\n                        queue.push(neighbor);\n                    }\n                }\n            }\n            clusters.push(Array.from(cluster));\n        }\n        return clusters;\n    }\n    // build the puzzle\n    // find longest word length\n    const longestWordLength = Math.max(...qnaList.map((item)=>item.answer.length), 0);\n    // build the grid size base on double the length of the longest word\n    const gridSize = Math.max(10, longestWordLength * 3);\n    // build empty grid puzzle\n    const indexedLetterMap = buildIndexedLetterMap(words);\n    const allConnections = generateIndexedConnections(indexedLetterMap);\n    //console.log(\"üîó All valid 2-word connections:\", allConnections);\n    // üß† Find clusters of connected words\n    const clusters = clusterWordsFromConnections(words, allConnections);\n    //console.log(\"üß© Found clusters:\", clusters);\n    // Helper to generate mutations from connections\n    function generateMutationsFromConnections(cluster, allConnections) {\n        const mutations = []; // Store all valid mutation paths\n        const MAX_MUTATIONS = 10000;\n        function dfs(path, used, visitedSet) {\n            if (mutations.length >= MAX_MUTATIONS) return;\n            const lastWord = path[path.length - 1]; // Get the last word in the current path\n            if (path.length === cluster.length) {\n                mutations.push([\n                    ...path\n                ]); // Save a copy of the valid path\n                return; // Stop further recursion\n            }\n            for (const conn of allConnections){\n                if (conn.from === lastWord && // ‚úÖ Must start from the current word\n                cluster.includes(conn.to) && // ‚úÖ The target word must be in the cluster\n                !visitedSet.has(conn.to) // ‚úÖ Make sure we haven‚Äôt used this word yet\n                ) {\n                    visitedSet.add(conn.to); // Mark the word as visited\n                    path.push(conn.to); // Add it to the current path\n                    dfs(path, used, visitedSet); // üîÅ Recurse deeper\n                    path.pop(); // üßπ Backtrack: remove last word added\n                    visitedSet.delete(conn.to); // üßπ Unmark word as visited\n                    if (mutations.length >= MAX_MUTATIONS) return; // short-circuit deeper\n                }\n            }\n        }\n        for (const startWord of cluster){\n            if (mutations.length >= MAX_MUTATIONS) break;\n            dfs([\n                startWord\n            ], new Set(), new Set([\n                startWord\n            ])); // üîÅ Start DFS from each word in the cluster\n        }\n        return mutations; // Return all generated mutation paths\n    }\n    function placeMutationToGrid(mutation, connections, gridSize, existingGrid = null, offset = null, placedSoFar = []) {\n        // üß± Create an empty grid of given size (2D array filled with nulls)\n        const grid = existingGrid ? existingGrid.map((row)=>[\n                ...row\n            ]) // üß† Clone to avoid mutation\n         : Array.from({\n            length: gridSize\n        }, ()=>Array(gridSize).fill(null));\n        // üì¶ Track placed word info (word, direction, location, etc.)\n        const placedWords = [];\n        const usedAnswerIndices = new Set(); // ‚úÖ TRACK used QnA indexes\n        let hasFallback = false;\n        // üéØ Place the first word in the center, horizontally\n        const startRow = offset ? offset.row : Math.floor(gridSize / 2);\n        const startCol = offset ? offset.col : Math.floor((gridSize - mutation[0].length) / 2);\n        // üìù Write the first word to the grid\n        for(let i = 0; i < mutation[0].length; i++){\n            grid[startRow][startCol + i] = mutation[0][i];\n        }\n        // üìå Save the placement info for the first word\n        let firstIndex = -1;\n        for(let k = 0; k < qnaList.length; k++){\n            if (qnaList[k].answer.toUpperCase() === mutation[0] && !usedAnswerIndices.has(k)) {\n                firstIndex = k;\n                usedAnswerIndices.add(k);\n                break;\n            }\n        }\n        placedWords.push({\n            word: mutation[0],\n            direction: \"across\",\n            start: {\n                row: startRow,\n                col: startCol\n            },\n            index: firstIndex\n        });\n        // üîÅ Try placing all remaining words in the mutation\n        for(let i = 1; i < mutation.length; i++){\n            const word = mutation[i]; // current word to place\n            const prev = mutation[i - 1]; // previous word it connects to\n            // üîó Find all valid connections from prev ‚Üí current word\n            const candidateConns = connections.filter((c)=>c.from === prev && c.to === word);\n            let placed = false;\n            // üîÅ Try each possible connection until one fits\n            for (const conn of candidateConns){\n                const prevPlaced = placedWords.find((p)=>p.word === conn.from);\n                if (!prevPlaced) continue;\n                if (placedWords.some((p)=>p.word === word) || placedSoFar.some((p)=>p.word === word)) continue;\n                // üß† Access how the previous word was connected before\n                const lastPlaced = placedWords.find((p)=>p.word === prevPlaced.word);\n                const lastToIndex = lastPlaced?.toIndex;\n                // üö´ Enforce 1-block spacing (no direct reuse or adjacent)\n                if (lastToIndex !== undefined && (conn.fromIndex === lastToIndex || conn.fromIndex === lastToIndex - 1 || conn.fromIndex === lastToIndex + 1)) {\n                    continue; // ‚ùå Skip this connection ‚Äî too close to last\n                }\n                const { row: pr, col: pc } = prevPlaced.start;\n                let newRow, newCol, direction;\n                if (prevPlaced.direction === \"across\") {\n                    // ‚Üï If previous was across, current goes down\n                    newRow = pr - conn.toIndex;\n                    newCol = pc + conn.fromIndex;\n                    direction = \"down\";\n                } else {\n                    // ‚Üî If previous was down, current goes across\n                    newRow = pr + conn.fromIndex;\n                    newCol = pc - conn.toIndex;\n                    direction = \"across\";\n                }\n                let fits = true; // üü¢ Assume the word fits unless proven otherwise\n                for(let k = 0; k < word.length; k++){\n                    // üßÆ Compute the row and column where this character will go\n                    const r = direction === \"across\" ? newRow : newRow + k; // If across, stay on same row; if down, move vertically\n                    const c = direction === \"across\" ? newCol + k : newCol; // If across, move horizontally; if down, stay in same column\n                    // üö´ Check if the position is out of bounds\n                    if (r < 0 || r >= gridSize || c < 0 || c >= gridSize) {\n                        fits = false; // ‚ùå Mark as invalid\n                        break; // ‚õî Exit the loop early\n                    }\n                    const cell = grid[r][c]; // üì¶ Get the current cell from the grid\n                    // üö´ Check for letter conflict: cell is filled with a different letter\n                    if (cell && cell !== word[k]) {\n                        fits = false; // ‚ùå Mark as invalid\n                        break; // ‚õî Exit the loop early\n                    }\n                }\n                if (!fits) continue; // ‚ùå Try next connection\n                /// üß± Check the cell before the first letter and after the last letter\n                let endSafe = true; // ‚úÖ Check if ends are clear\n                let sideSafe = true; // ‚úÖ Check if side neighbors of first & last letters are clear\n                if (direction === \"across\") {\n                    const before = grid[newRow]?.[newCol - 1]; // ‚¨ÖÔ∏è Left of first letter\n                    const after = grid[newRow]?.[newCol + word.length]; // ‚û°Ô∏è Right of last letter\n                    if (before && before !== null || after && after !== null) {\n                        endSafe = false;\n                    }\n                    // üîç Check up/down of first letter (only if not connection point)\n                    if (conn.toIndex !== 0) {\n                        const up = grid[newRow - 1]?.[newCol];\n                        const down = grid[newRow + 1]?.[newCol];\n                        if (up && up !== null || down && down !== null) {\n                            sideSafe = false;\n                        }\n                    }\n                    // üîç Check up/down of last letter (only if not connection point)\n                    const lastCol = newCol + word.length - 1;\n                    if (conn.toIndex !== word.length - 1) {\n                        const up = grid[newRow - 1]?.[lastCol];\n                        const down = grid[newRow + 1]?.[lastCol];\n                        if (up && up !== null || down && down !== null) {\n                            sideSafe = false;\n                        }\n                    }\n                    // üîÅ Check up/down 1 block for all non-connecting letters (middle letters)\n                    for(let k = 0; k < word.length; k++){\n                        if (k === conn.toIndex) continue; // üö´ Skip connection letter\n                        const r = newRow;\n                        const c = newCol + k;\n                        const up = grid[r - 1]?.[c];\n                        const down = grid[r + 1]?.[c];\n                        if (up && up !== null || down && down !== null) {\n                            sideSafe = false; // ‚ùå Letter has neighbors above/below\n                            break;\n                        }\n                    }\n                } else {\n                    const before = grid[newRow - 1]?.[newCol]; // ‚¨ÜÔ∏è Above first letter\n                    const after = grid[newRow + word.length]?.[newCol]; // ‚¨áÔ∏è Below last letter\n                    if (before && before !== null || after && after !== null) {\n                        endSafe = false;\n                    }\n                    // üîç Check left/right of first letter (only if not connection point)\n                    if (conn.toIndex !== 0) {\n                        const left = grid[newRow]?.[newCol - 1];\n                        const right = grid[newRow]?.[newCol + 1];\n                        if (left && left !== null || right && right !== null) {\n                            sideSafe = false;\n                        }\n                    }\n                    // üîç Check left/right of last letter (only if not connection point)\n                    const lastRow = newRow + word.length - 1;\n                    if (conn.toIndex !== word.length - 1) {\n                        const left = grid[lastRow]?.[newCol - 1];\n                        const right = grid[lastRow]?.[newCol + 1];\n                        if (left && left !== null || right && right !== null) {\n                            sideSafe = false;\n                        }\n                    }\n                    // üîÅ Check left/right 1 block for all non-connecting letters (middle letters)\n                    for(let k = 0; k < word.length; k++){\n                        if (k === conn.toIndex) continue; // üö´ Skip connection letter\n                        const r = newRow + k;\n                        const c = newCol;\n                        const left = grid[r]?.[c - 1];\n                        const right = grid[r]?.[c + 1];\n                        if (left && left !== null || right && right !== null) {\n                            sideSafe = false; // ‚ùå Letter has neighbors left/right\n                            break;\n                        }\n                    }\n                }\n                // üö´ Skip this connection if the ends or sides aren't safe\n                if (!endSafe || !sideSafe) continue;\n                // ‚úÖ All checks passed ‚Äì now place the word on the grid\n                for(let k = 0; k < word.length; k++){\n                    const r = direction === \"across\" ? newRow : newRow + k; // üßÆ Calculate row\n                    const c = direction === \"across\" ? newCol + k : newCol; // üßÆ Calculate column\n                    grid[r][c] = word[k]; // ‚úçÔ∏è Write the character to the grid\n                }\n                // üîç Find the original index of this word from qnaList\n                let foundIndex = -1;\n                for(let k = 0; k < qnaList.length; k++){\n                    if (qnaList[k].answer.toUpperCase() === word && !usedAnswerIndices.has(k)) {\n                        foundIndex = k;\n                        usedAnswerIndices.add(k); // ‚úÖ Mark as used\n                        break;\n                    }\n                }\n                if (foundIndex === -1) continue; // üîÑ Skip if the word isn't found in the original list\n                // üìù Save the word's placement info for rendering or exporting later\n                placedWords.push({\n                    word,\n                    direction,\n                    start: {\n                        row: newRow,\n                        col: newCol\n                    },\n                    index: foundIndex,\n                    mutationIndex: i,\n                    connectedFrom: conn.from,\n                    connectedTo: conn.to,\n                    fromIndex: conn.fromIndex,\n                    toIndex: conn.toIndex\n                });\n                placed = true;\n                break; // ‚úÖ Done with this word\n            }\n            if (!placed) {\n                const fallbackWord = word;\n                hasFallback = true;\n                const usedShape = getUsedSize(grid);\n                const directions = usedShape.rows >= usedShape.cols ? [\n                    \"down\"\n                ] : [\n                    \"across\"\n                ];\n                for (const direction of directions){\n                    const centerRow = Math.floor(gridSize / 2);\n                    const centerCol = Math.floor(gridSize / 2);\n                    const rowOffsets = Array.from({\n                        length: gridSize\n                    }, (_, i)=>i - centerRow).sort((a, b)=>Math.abs(a) - Math.abs(b));\n                    const colOffsets = Array.from({\n                        length: gridSize\n                    }, (_, i)=>i - centerCol).sort((a, b)=>Math.abs(a) - Math.abs(b));\n                    for (const dr of rowOffsets){\n                        const row = centerRow + dr;\n                        if (row < 0 || row >= gridSize) continue;\n                        for (const dc of colOffsets){\n                            const col = centerCol + dc;\n                            if (col < 0 || col >= gridSize) continue;\n                            let fits = true;\n                            for(let k = 0; k < fallbackWord.length; k++){\n                                const r = direction === \"across\" ? row : row + k;\n                                const c = direction === \"across\" ? col + k : col;\n                                if (r < 0 || r >= gridSize || c < 0 || c >= gridSize) {\n                                    fits = false;\n                                    break;\n                                }\n                                if (grid[r][c] && grid[r][c] !== fallbackWord[k]) {\n                                    fits = false;\n                                    break;\n                                }\n                                const neighbors = [\n                                    [\n                                        r - 1,\n                                        c\n                                    ],\n                                    [\n                                        r + 1,\n                                        c\n                                    ],\n                                    [\n                                        r,\n                                        c - 1\n                                    ],\n                                    [\n                                        r,\n                                        c + 1\n                                    ],\n                                    [\n                                        r - 1,\n                                        c - 1\n                                    ],\n                                    [\n                                        r - 1,\n                                        c + 1\n                                    ],\n                                    [\n                                        r + 1,\n                                        c - 1\n                                    ],\n                                    [\n                                        r + 1,\n                                        c + 1\n                                    ]\n                                ];\n                                for (const [nr, nc] of neighbors){\n                                    if (nr >= 0 && nr < gridSize && nc >= 0 && nc < gridSize && grid[nr][nc] && grid[nr][nc] !== fallbackWord[k]) {\n                                        fits = false;\n                                        break;\n                                    }\n                                }\n                                if (!fits) break;\n                            }\n                            const beforeR = direction === \"across\" ? row : row - 1;\n                            const beforeC = direction === \"across\" ? col - 1 : col;\n                            const afterR = direction === \"across\" ? row : row + fallbackWord.length;\n                            const afterC = direction === \"across\" ? col + fallbackWord.length : col;\n                            if (grid[beforeR]?.[beforeC] || grid[afterR]?.[afterC]) continue;\n                            if (fits) {\n                                if (placed == true) {\n                                    break;\n                                }\n                                for(let k = 0; k < fallbackWord.length; k++){\n                                    const r = direction === \"across\" ? row : row + k;\n                                    const c = direction === \"across\" ? col + k : col;\n                                    grid[r][c] = fallbackWord[k];\n                                }\n                                let foundIndex = -1;\n                                for(let k = 0; k < qnaList.length; k++){\n                                    if (qnaList[k].answer.toUpperCase() === fallbackWord && !usedAnswerIndices.has(k)) {\n                                        foundIndex = k;\n                                        usedAnswerIndices.add(k);\n                                        break;\n                                    }\n                                }\n                                placedWords.push({\n                                    word: fallbackWord,\n                                    direction,\n                                    start: {\n                                        row,\n                                        col\n                                    },\n                                    index: foundIndex,\n                                    mutationIndex: i,\n                                    connectedFrom: null,\n                                    connectedTo: fallbackWord,\n                                    fromIndex: null,\n                                    toIndex: null\n                                });\n                                placed = true;\n                                break;\n                            }\n                        }\n                        if (placed) break;\n                    }\n                }\n                if (!placed) break;\n            }\n            if (!placed) break;\n        }\n        // ‚úÖ Return the built grid and word placement info\n        return {\n            grid,\n            placedWords: placedSoFar.concat(placedWords),\n            hasFallback\n        };\n    }\n    // üîÅ Generate mutations for each cluster\n    const clusterMutations = clusters.map((cluster)=>{\n        const clusterWords = cluster;\n        const clusterConns = allConnections.filter((c)=>clusterWords.includes(c.from) && clusterWords.includes(c.to));\n        const mutations = generateMutationsFromConnections(clusterWords, clusterConns);\n        return {\n            cluster,\n            mutations\n        };\n    });\n    function getUsedSize(grid) {\n        let top = grid.length, bottom = 0, left = grid[0].length, right = 0;\n        for(let r = 0; r < grid.length; r++){\n            for(let c = 0; c < grid[0].length; c++){\n                if (grid[r][c]) {\n                    top = Math.min(top, r);\n                    bottom = Math.max(bottom, r);\n                    left = Math.min(left, c);\n                    right = Math.max(right, c);\n                }\n            }\n        }\n        return {\n            rows: bottom - top + 1,\n            cols: right - left + 1\n        };\n    }\n    function getNextClusterOffset(grid) {\n        let maxRow = 0;\n        for(let r = 0; r < grid.length; r++){\n            for(let c = 0; c < grid[0].length; c++){\n                if (grid[r][c]) {\n                    maxRow = Math.max(maxRow, r);\n                }\n            }\n        }\n        // Start new cluster 3 rows below the last used row\n        return {\n            row: maxRow + 3,\n            col: Math.floor(grid[0].length / 2)\n        };\n    }\n    // üîÅ Loop through all clusters' generated mutations\n    let combinedGrid = null;\n    let placedSoFar = [];\n    for (const { cluster, mutations } of clusterMutations){\n        let bestIsPerfect = false;\n        let bestPerfect = null;\n        const clusterConnections = allConnections.filter((c)=>cluster.includes(c.from) && cluster.includes(c.to));\n        let bestForCluster = null;\n        let bestArea = Infinity;\n        let attempts = 0;\n        for (const mutation of mutations){\n            if (attempts++ > 10000) break;\n            // Determine offset: center for first cluster, offset for next clusters\n            const offset = combinedGrid ? getNextClusterOffset(combinedGrid) : null;\n            const result = placeMutationToGrid(mutation, clusterConnections, gridSize, combinedGrid, offset, placedSoFar);\n            if (!result) continue;\n            const { grid, placedWords, hasFallback } = result;\n            const isPerfect = !hasFallback;\n            const used = getUsedSize(grid);\n            const area = used.rows * used.cols;\n            if (!bestForCluster) {\n                bestForCluster = {\n                    grid,\n                    placedWords\n                };\n                bestArea = area;\n                bestIsPerfect = isPerfect;\n                bestPerfect = isPerfect ? {\n                    grid,\n                    placedWords,\n                    area\n                } : null;\n            } else {\n                const isSmallerEnoughThanPerfect = bestPerfect && area < bestPerfect.area - 49; // 7x7 = 49\n                if (isPerfect) {\n                    if (!bestIsPerfect || area < bestPerfect.area) {\n                        bestPerfect = {\n                            grid,\n                            placedWords,\n                            area\n                        };\n                        bestForCluster = {\n                            grid,\n                            placedWords\n                        };\n                        bestArea = area;\n                        bestIsPerfect = true;\n                    }\n                } else if (!bestIsPerfect || isSmallerEnoughThanPerfect) {\n                    bestForCluster = {\n                        grid,\n                        placedWords\n                    };\n                    bestArea = area;\n                }\n            }\n        }\n        if (bestForCluster) {\n            combinedGrid = bestForCluster.grid;\n            placedSoFar = bestForCluster.placedWords;\n        }\n    }\n    function assignClueNumbers(placedWords) {\n        const clueMap = new Map(); // üîê Prevent duplicate clue numbers\n        let next = 1;\n        for (const word of placedWords){\n            const key = `${word.start.row},${word.start.col}`; // üìç Identify start cell\n            if (!clueMap.has(key)) {\n                clueMap.set(key, next++); // üÜï First time we see this start cell\n            }\n            word.clueNumber = clueMap.get(key); // üß† Share number for same cell\n        }\n    }\n    // ‚úÖ Skip everything if no input, prevent crash at the beginning \n    if (qnaList.length === 0) {\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            grid: [],\n            placedWords: []\n        });\n    }\n    // assignClueNumbers(placedSoFar);\n    // üîç Filter out broken placements\n    const cleanedPlacedWords = placedSoFar.filter((w)=>w.start && w.direction && typeof w.index === \"number\");\n    assignClueNumbers(cleanedPlacedWords);\n    // üí° Add this: reconstruct the answer for each placed word\n    for (const word of cleanedPlacedWords){\n        if (!word.answer) {\n            word.answer = qnaList[word.index]?.answer?.toUpperCase();\n        }\n    }\n    return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n        grid: combinedGrid || [],\n        placedWords: cleanedPlacedWords\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9hcHAvYXBpL2dlbmVyYXRlLXB1enpsZS9yb3V0ZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEyQztBQUUzQyxxRUFBcUU7QUFFOUQsZUFBZUMsS0FBS0MsR0FBRztJQUMxQixNQUFNLEVBQUVDLE9BQU8sRUFBRSxHQUFHLE1BQU1ELElBQUlFLElBQUk7SUFFbEMsSUFBSSxDQUFDQyxNQUFNQyxPQUFPLENBQUNILFlBQVlBLFFBQVFJLE1BQU0sS0FBSyxHQUFHO1FBQ2pELE9BQU9QLHFEQUFZQSxDQUFDSSxJQUFJLENBQUM7WUFBRUksTUFBTSxFQUFFO1lBQUVDLGFBQWEsRUFBRTtRQUFDLEdBQUc7WUFBRUMsUUFBUTtRQUFJO0lBQzFFO0lBRUEsTUFBTUMsUUFBUVIsUUFBUVMsR0FBRyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxNQUFNLENBQUNDLFdBQVc7SUFFbkQsbUdBQW1HO0lBQ25HLDZDQUE2QztJQUU3Qyw4Q0FBOEM7SUFDOUMsU0FBU0Msc0JBQXNCTCxLQUFLO1FBQ2hDLE1BQU1DLE1BQU0sQ0FBQztRQUNiLEtBQUssTUFBTUssUUFBUU4sTUFBTztZQUN0QixJQUFLLElBQUlPLElBQUksR0FBR0EsSUFBSUQsS0FBS1YsTUFBTSxFQUFFVyxJQUFLO2dCQUNsQyxNQUFNQyxTQUFTRixJQUFJLENBQUNDLEVBQUU7Z0JBQ3RCLElBQUksQ0FBQ04sR0FBRyxDQUFDTyxPQUFPLEVBQUVQLEdBQUcsQ0FBQ08sT0FBTyxHQUFHLEVBQUU7Z0JBQ2xDUCxHQUFHLENBQUNPLE9BQU8sQ0FBQ0MsSUFBSSxDQUFDO29CQUFFSDtvQkFBTUksT0FBT0g7Z0JBQUU7WUFDdEM7UUFDSjtRQUNBLE9BQU9OO0lBQ1g7SUFFQSxvREFBb0Q7SUFDcEQsU0FBU1UsMkJBQTJCQyxnQkFBZ0I7UUFDaEQsTUFBTUMsY0FBYyxFQUFFO1FBRXRCLEtBQUssTUFBTSxDQUFDTCxRQUFRTSxRQUFRLElBQUlDLE9BQU9ELE9BQU8sQ0FBQ0Ysa0JBQW1CO1lBQzlELElBQUssSUFB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QU0sZ0NBQWdDO1FBQ3hFO0lBQ0o7SUFFQSxpRUFBaUU7SUFDakUsSUFBSS9KLFFBQVFJLE1BQU0sS0FBSyxHQUFHO1FBQ3RCLE9BQU9QLHFEQUFZQSxDQUFDSSxJQUFJLENBQUM7WUFBRUksTUFBTSxFQUFFO1lBQUVDLGFBQWEsRUFBRTtRQUFDO0lBQ3pEO0lBQ0Esa0NBQWtDO0lBQ2xDLGtDQUFrQztJQUNsQyxNQUFNNkoscUJBQXFCbkcsWUFBWWUsTUFBTSxDQUFDcUYsQ0FBQUEsSUFBS0EsRUFBRXhGLEtBQUssSUFBSXdGLEVBQUV6RixTQUFTLElBQUksT0FBT3lGLEVBQUVsSixLQUFLLEtBQUs7SUFDaEd5SSxrQkFBa0JRO0lBQ2xCLDJEQUEyRDtJQUMzRCxLQUFLLE1BQU1ySixRQUFRcUosbUJBQW9CO1FBQ25DLElBQUksQ0FBQ3JKLEtBQUtILE1BQU0sRUFBRTtZQUNkRyxLQUFLSCxNQUFNLEdBQUdYLE9BQU8sQ0FBQ2MsS0FBS0ksS0FBSyxDQUFDLEVBQUVQLFFBQVFDO1FBQy9DO0lBQ0o7SUFFQSxPQUFPZixxREFBWUEsQ0FBQ0ksSUFBSSxDQUFDO1FBQ3JCSSxNQUFNMEksZ0JBQWdCLEVBQUU7UUFDeEJ6SSxhQUFhNko7SUFDakI7QUFFSiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxhbmh2b1xcRGVza3RvcFxcSGlwcG9DYW1wdXNcXGZyb250ZW5kXFxhcHBcXGFwaVxcZ2VuZXJhdGUtcHV6emxlXFxyb3V0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZXh0UmVzcG9uc2UgfSBmcm9tICduZXh0L3NlcnZlcic7XHJcblxyXG4vLyBBZGQgeW91ciBwdXp6bGUgbG9naWMgZnVuY3Rpb25zIGhlcmUgKGJ1aWxkSW5kZXhlZExldHRlck1hcCwgZXRjLilcclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBQT1NUKHJlcSkge1xyXG4gICAgY29uc3QgeyBxbmFMaXN0IH0gPSBhd2FpdCByZXEuanNvbigpO1xyXG5cclxuICAgIGlmICghQXJyYXkuaXNBcnJheShxbmFMaXN0KSB8fCBxbmFMaXN0Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IGdyaWQ6IFtdLCBwbGFjZWRXb3JkczogW10gfSwgeyBzdGF0dXM6IDIwMCB9KTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB3b3JkcyA9IHFuYUxpc3QubWFwKHEgPT4gcS5hbnN3ZXIudG9VcHBlckNhc2UoKSk7XHJcblxyXG4gICAgLy8gSW5zZXJ0IHlvdXIgYnVpbGRJbmRleGVkTGV0dGVyTWFwLCBnZW5lcmF0ZUluZGV4ZWRDb25uZWN0aW9ucywgY2x1c3RlcldvcmRzRnJvbUNvbm5lY3Rpb25zLCBldGMuXHJcbiAgICAvLyBUaGVuIHVzZSB0aGVtIGhlcmUgdG8gZ2VuZXJhdGUgeW91ciBwdXp6bGVcclxuXHJcbiAgICAvLyDwn6egIEJ1aWxkIGluZGV4ZWQgbGV0dGVyIG1hcCBmdW5jdGlvbiAobmV3ISlcclxuICAgIGZ1bmN0aW9uIGJ1aWxkSW5kZXhlZExldHRlck1hcCh3b3Jkcykge1xyXG4gICAgICAgIGNvbnN0IG1hcCA9IHt9O1xyXG4gICAgICAgIGZvciAoY29uc3Qgd29yZCBvZiB3b3Jkcykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxldHRlciA9IHdvcmRbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoIW1hcFtsZXR0ZXJdKSBtYXBbbGV0dGVyXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgbWFwW2xldHRlcl0ucHVzaCh7IHdvcmQsIGluZGV4OiBpIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtYXA7XHJcbiAgICB9XHJcblxyXG4gICAgLy8g8J+UlyBCdWlsZCBpbmRleGVkIGNvbm5lY3Rpb25zIGZyb20gdGhlIGluZGV4ZWQgbWFwXHJcbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUluZGV4ZWRDb25uZWN0aW9ucyhpbmRleGVkTGV0dGVyTWFwKSB7XHJcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbnMgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBbbGV0dGVyLCBlbnRyaWVzXSBvZiBPYmplY3QuZW50cmllcyhpbmRleGVkTGV0dGVyTWFwKSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZW50cmllcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBqKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZnJvbSA9IGVudHJpZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG8gPSBlbnRyaWVzW2pdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbS53b3JkID09PSB0by53b3JkKSBjb250aW51ZTsgLy8g4p2MIHNraXAgc2FtZSB3b3JkXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiBmcm9tLndvcmQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvOiB0by53b3JkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWE6IGxldHRlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbUluZGV4OiBmcm9tLmluZGV4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b0luZGV4OiB0by5pbmRleCxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb25zO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY2x1c3RlcldvcmRzRnJvbUNvbm5lY3Rpb25zKHdvcmRzLCBjb25uZWN0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IGdyYXBoID0ge307XHJcbiAgICAgICAgZm9yIChjb25zdCB3b3JkIG9mIHdvcmRzKSB7XHJcbiAgICAgICAgICAgIGdyYXBoW3dvcmRdID0gbmV3IFNldCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBjb25uIG9mIGNvbm5lY3Rpb25zKSB7XHJcbiAgICAgICAgICAgIGdyYXBoW2Nvbm4uZnJvbV0uYWRkKGNvbm4udG8pO1xyXG4gICAgICAgICAgICBncmFwaFtjb25uLnRvXS5hZGQoY29ubi5mcm9tKTsgLy8gYmktZGlyZWN0aW9uYWxcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHZpc2l0ZWQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgY29uc3QgY2x1c3RlcnMgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCB3b3JkIG9mIHdvcmRzKSB7XHJcbiAgICAgICAgICAgIGlmICh2aXNpdGVkLmhhcyh3b3JkKSkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBjbHVzdGVyID0gbmV3IFNldCgpO1xyXG4gICAgICAgICAgICBjb25zdCBxdWV1ZSA9IFt3b3JkXTtcclxuXHJcbiAgICAgICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBxdWV1ZS5wb3AoKTtcclxuICAgICAgICAgICAgICAgIGlmICh2aXNpdGVkLmhhcyhjdXJyZW50KSkgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB2aXNpdGVkLmFkZChjdXJyZW50KTtcclxuICAgICAgICAgICAgICAgIGNsdXN0ZXIuYWRkKGN1cnJlbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbmVpZ2hib3Igb2YgZ3JhcGhbY3VycmVudF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXZpc2l0ZWQuaGFzKG5laWdoYm9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKG5laWdoYm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNsdXN0ZXJzLnB1c2goQXJyYXkuZnJvbShjbHVzdGVyKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY2x1c3RlcnM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYnVpbGQgdGhlIHB1enpsZVxyXG5cclxuICAgIC8vIGZpbmQgbG9uZ2VzdCB3b3JkIGxlbmd0aFxyXG4gICAgY29uc3QgbG9uZ2VzdFdvcmRMZW5ndGggPSBNYXRoLm1heCguLi5xbmFMaXN0Lm1hcChpdGVtID0+IGl0ZW0uYW5zd2VyLmxlbmd0aCksIDApO1xyXG5cclxuICAgIC8vIGJ1aWxkIHRoZSBncmlkIHNpemUgYmFzZSBvbiBkb3VibGUgdGhlIGxlbmd0aCBvZiB0aGUgbG9uZ2VzdCB3b3JkXHJcbiAgICBjb25zdCBncmlkU2l6ZSA9IE1hdGgubWF4KDEwLCBsb25nZXN0V29yZExlbmd0aCAqIDMpO1xyXG5cclxuICAgIC8vIGJ1aWxkIGVtcHR5IGdyaWQgcHV6emxlXHJcblxyXG4gICAgY29uc3QgaW5kZXhlZExldHRlck1hcCA9IGJ1aWxkSW5kZXhlZExldHRlck1hcCh3b3Jkcyk7XHJcbiAgICBjb25zdCBhbGxDb25uZWN0aW9ucyA9IGdlbmVyYXRlSW5kZXhlZENvbm5lY3Rpb25zKGluZGV4ZWRMZXR0ZXJNYXApO1xyXG4gICAgLy9jb25zb2xlLmxvZyhcIvCflJcgQWxsIHZhbGlkIDItd29yZCBjb25uZWN0aW9uczpcIiwgYWxsQ29ubmVjdGlvbnMpO1xyXG5cclxuICAgIC8vIPCfp6AgRmluZCBjbHVzdGVycyBvZiBjb25uZWN0ZWQgd29yZHNcclxuICAgIGNvbnN0IGNsdXN0ZXJzID0gY2x1c3RlcldvcmRzRnJvbUNvbm5lY3Rpb25zKHdvcmRzLCBhbGxDb25uZWN0aW9ucyk7XHJcbiAgICAvL2NvbnNvbGUubG9nKFwi8J+nqSBGb3VuZCBjbHVzdGVyczpcIiwgY2x1c3RlcnMpO1xyXG5cclxuICAgIC8vIEhlbHBlciB0byBnZW5lcmF0ZSBtdXRhdGlvbnMgZnJvbSBjb25uZWN0aW9uc1xyXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVNdXRhdGlvbnNGcm9tQ29ubmVjdGlvbnMoY2x1c3RlciwgYWxsQ29ubmVjdGlvbnMpIHtcclxuICAgICAgICBjb25zdCBtdXRhdGlvbnMgPSBbXTsgLy8gU3RvcmUgYWxsIHZhbGlkIG11dGF0aW9uIHBhdGhzXHJcbiAgICAgICAgY29uc3QgTUFYX01VVEFUSU9OUyA9IDEwMDAwO1xyXG4gICAgICAgIGZ1bmN0aW9uIGRmcyhwYXRoLCB1c2VkLCB2aXNpdGVkU2V0KSB7XHJcbiAgICAgICAgICAgIGlmIChtdXRhdGlvbnMubGVuZ3RoID49IE1BWF9NVVRBVElPTlMpIHJldHVybjtcclxuICAgICAgICAgICAgY29uc3QgbGFzdFdvcmQgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07IC8vIEdldCB0aGUgbGFzdCB3b3JkIGluIHRoZSBjdXJyZW50IHBhdGhcclxuXHJcbiAgICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gY2x1c3Rlci5sZW5ndGgpIHsgLy8g4pyFIElmIHdl4oCZdmUgdXNlZCBhbGwgd29yZHMgaW4gdGhlIGNsdXN0ZXJcclxuICAgICAgICAgICAgICAgIG11dGF0aW9ucy5wdXNoKFsuLi5wYXRoXSk7IC8vIFNhdmUgYSBjb3B5IG9mIHRoZSB2YWxpZCBwYXRoXHJcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIFN0b3AgZnVydGhlciByZWN1cnNpb25cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yIChjb25zdCBjb25uIG9mIGFsbENvbm5lY3Rpb25zKSB7IC8vIPCflIEgTG9vcCB0aHJvdWdoIGFsbCBwb3NzaWJsZSBjb25uZWN0aW9uc1xyXG4gICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbm4uZnJvbSA9PT0gbGFzdFdvcmQgJiYgICAgICAgICAgIC8vIOKchSBNdXN0IHN0YXJ0IGZyb20gdGhlIGN1cnJlbnQgd29yZFxyXG4gICAgICAgICAgICAgICAgICAgIGNsdXN0ZXIuaW5jbHVkZXMoY29ubi50bykgJiYgICAgICAgIC8vIOKchSBUaGUgdGFyZ2V0IHdvcmQgbXVzdCBiZSBpbiB0aGUgY2x1c3RlclxyXG4gICAgICAgICAgICAgICAgICAgICF2aXNpdGVkU2V0Lmhhcyhjb25uLnRvKSAgICAgICAgICAgIC8vIOKchSBNYWtlIHN1cmUgd2UgaGF2ZW7igJl0IHVzZWQgdGhpcyB3b3JkIHlldFxyXG4gICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlzaXRlZFNldC5hZGQoY29ubi50byk7ICAgICAvLyBNYXJrIHRoZSB3b3JkIGFzIHZpc2l0ZWRcclxuICAgICAgICAgICAgICAgICAgICBwYXRoLnB1c2goY29ubi50byk7ICAgICAgICAgIC8vIEFkZCBpdCB0byB0aGUgY3VycmVudCBwYXRoXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGRmcyhwYXRoLCB1c2VkLCB2aXNpdGVkU2V0KTsgLy8g8J+UgSBSZWN1cnNlIGRlZXBlclxyXG5cclxuICAgICAgICAgICAgICAgICAgICBwYXRoLnBvcCgpOyAgICAgICAgICAgICAgICAgIC8vIPCfp7kgQmFja3RyYWNrOiByZW1vdmUgbGFzdCB3b3JkIGFkZGVkXHJcbiAgICAgICAgICAgICAgICAgICAgdmlzaXRlZFNldC5kZWxldGUoY29ubi50byk7IC8vIPCfp7kgVW5tYXJrIHdvcmQgYXMgdmlzaXRlZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtdXRhdGlvbnMubGVuZ3RoID49IE1BWF9NVVRBVElPTlMpIHJldHVybjsgLy8gc2hvcnQtY2lyY3VpdCBkZWVwZXJcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBzdGFydFdvcmQgb2YgY2x1c3Rlcikge1xyXG4gICAgICAgICAgICBpZiAobXV0YXRpb25zLmxlbmd0aCA+PSBNQVhfTVVUQVRJT05TKSBicmVhaztcclxuICAgICAgICAgICAgZGZzKFtzdGFydFdvcmRdLCBuZXcgU2V0KCksIG5ldyBTZXQoW3N0YXJ0V29yZF0pKTsgLy8g8J+UgSBTdGFydCBERlMgZnJvbSBlYWNoIHdvcmQgaW4gdGhlIGNsdXN0ZXJcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBtdXRhdGlvbnM7IC8vIFJldHVybiBhbGwgZ2VuZXJhdGVkIG11dGF0aW9uIHBhdGhzXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcGxhY2VNdXRhdGlvblRvR3JpZChtdXRhdGlvbiwgY29ubmVjdGlvbnMsIGdyaWRTaXplLCBleGlzdGluZ0dyaWQgPSBudWxsLCBvZmZzZXQgPSBudWxsLCBwbGFjZWRTb0ZhciA9IFtdKSB7XHJcblxyXG4gICAgICAgIC8vIPCfp7EgQ3JlYXRlIGFuIGVtcHR5IGdyaWQgb2YgZ2l2ZW4gc2l6ZSAoMkQgYXJyYXkgZmlsbGVkIHdpdGggbnVsbHMpXHJcbiAgICAgICAgY29uc3QgZ3JpZCA9IGV4aXN0aW5nR3JpZFxyXG4gICAgICAgICAgICA/IGV4aXN0aW5nR3JpZC5tYXAocm93ID0+IFsuLi5yb3ddKSAvLyDwn6egIENsb25lIHRvIGF2b2lkIG11dGF0aW9uXHJcbiAgICAgICAgICAgIDogQXJyYXkuZnJvbSh7IGxlbmd0aDogZ3JpZFNpemUgfSwgKCkgPT4gQXJyYXkoZ3JpZFNpemUpLmZpbGwobnVsbCkpO1xyXG5cclxuXHJcbiAgICAgICAgLy8g8J+TpiBUcmFjayBwbGFjZWQgd29yZCBpbmZvICh3b3JkLCBkaXJlY3Rpb24sIGxvY2F0aW9uLCBldGMuKVxyXG4gICAgICAgIGNvbnN0IHBsYWNlZFdvcmRzID0gW107XHJcbiAgICAgICAgY29uc3QgdXNlZEFuc3dlckluZGljZXMgPSBuZXcgU2V0KCk7IC8vIOKchSBUUkFDSyB1c2VkIFFuQSBpbmRleGVzXHJcblxyXG4gICAgICAgIGxldCBoYXNGYWxsYmFjayA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvLyDwn46vIFBsYWNlIHRoZSBmaXJzdCB3b3JkIGluIHRoZSBjZW50ZXIsIGhvcml6b250YWxseVxyXG4gICAgICAgIGNvbnN0IHN0YXJ0Um93ID0gb2Zmc2V0ID8gb2Zmc2V0LnJvdyA6IE1hdGguZmxvb3IoZ3JpZFNpemUgLyAyKTtcclxuICAgICAgICBjb25zdCBzdGFydENvbCA9IG9mZnNldCA/IG9mZnNldC5jb2wgOiBNYXRoLmZsb29yKChncmlkU2l6ZSAtIG11dGF0aW9uWzBdLmxlbmd0aCkgLyAyKTtcclxuXHJcbiAgICAgICAgLy8g8J+TnSBXcml0ZSB0aGUgZmlyc3Qgd29yZCB0byB0aGUgZ3JpZFxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb25bMF0ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZ3JpZFtzdGFydFJvd11bc3RhcnRDb2wgKyBpXSA9IG11dGF0aW9uWzBdW2ldO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g8J+TjCBTYXZlIHRoZSBwbGFjZW1lbnQgaW5mbyBmb3IgdGhlIGZpcnN0IHdvcmRcclxuICAgICAgICBsZXQgZmlyc3RJbmRleCA9IC0xO1xyXG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgcW5hTGlzdC5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICBpZiAocW5hTGlzdFtrXS5hbnN3ZXIudG9VcHBlckNhc2UoKSA9PT0gbXV0YXRpb25bMF0gJiYgIXVzZWRBbnN3ZXJJbmRpY2VzLmhhcyhrKSkge1xyXG4gICAgICAgICAgICAgICAgZmlyc3RJbmRleCA9IGs7XHJcbiAgICAgICAgICAgICAgICB1c2VkQW5zd2VySW5kaWNlcy5hZGQoayk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcGxhY2VkV29yZHMucHVzaCh7XHJcbiAgICAgICAgICAgIHdvcmQ6IG11dGF0aW9uWzBdLFxyXG4gICAgICAgICAgICBkaXJlY3Rpb246IFwiYWNyb3NzXCIsXHJcbiAgICAgICAgICAgIHN0YXJ0OiB7IHJvdzogc3RhcnRSb3csIGNvbDogc3RhcnRDb2wgfSxcclxuICAgICAgICAgICAgaW5kZXg6IGZpcnN0SW5kZXgsIC8vIOKchSBDb3JyZWN0IGluZGV4IGZyb20gcW5hTGlzdFxyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgLy8g8J+UgSBUcnkgcGxhY2luZyBhbGwgcmVtYWluaW5nIHdvcmRzIGluIHRoZSBtdXRhdGlvblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbXV0YXRpb24ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3Qgd29yZCA9IG11dGF0aW9uW2ldOyAgICAgICAgICAgLy8gY3VycmVudCB3b3JkIHRvIHBsYWNlXHJcbiAgICAgICAgICAgIGNvbnN0IHByZXYgPSBtdXRhdGlvbltpIC0gMV07ICAgICAgIC8vIHByZXZpb3VzIHdvcmQgaXQgY29ubmVjdHMgdG9cclxuXHJcbiAgICAgICAgICAgIC8vIPCflJcgRmluZCBhbGwgdmFsaWQgY29ubmVjdGlvbnMgZnJvbSBwcmV2IOKGkiBjdXJyZW50IHdvcmRcclxuICAgICAgICAgICAgY29uc3QgY2FuZGlkYXRlQ29ubnMgPSBjb25uZWN0aW9ucy5maWx0ZXIoYyA9PiBjLmZyb20gPT09IHByZXYgJiYgYy50byA9PT0gd29yZCk7XHJcbiAgICAgICAgICAgIGxldCBwbGFjZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIC8vIPCflIEgVHJ5IGVhY2ggcG9zc2libGUgY29ubmVjdGlvbiB1bnRpbCBvbmUgZml0c1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNvbm4gb2YgY2FuZGlkYXRlQ29ubnMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZQbGFjZWQgPSBwbGFjZWRXb3Jkcy5maW5kKHAgPT4gcC53b3JkID09PSBjb25uLmZyb20pO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2UGxhY2VkKSBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGlmIChwbGFjZWRXb3Jkcy5zb21lKHAgPT4gcC53b3JkID09PSB3b3JkKSB8fCBwbGFjZWRTb0Zhci5zb21lKHAgPT4gcC53b3JkID09PSB3b3JkKSkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8g8J+noCBBY2Nlc3MgaG93IHRoZSBwcmV2aW91cyB3b3JkIHdhcyBjb25uZWN0ZWQgYmVmb3JlXHJcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0UGxhY2VkID0gcGxhY2VkV29yZHMuZmluZChwID0+IHAud29yZCA9PT0gcHJldlBsYWNlZC53b3JkKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RUb0luZGV4ID0gbGFzdFBsYWNlZD8udG9JbmRleDtcclxuICAgICAgICAgICAgICAgIC8vIPCfmqsgRW5mb3JjZSAxLWJsb2NrIHNwYWNpbmcgKG5vIGRpcmVjdCByZXVzZSBvciBhZGphY2VudClcclxuICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgICBsYXN0VG9JbmRleCAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKGNvbm4uZnJvbUluZGV4ID09PSBsYXN0VG9JbmRleCB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uLmZyb21JbmRleCA9PT0gbGFzdFRvSW5kZXggLSAxIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm4uZnJvbUluZGV4ID09PSBsYXN0VG9JbmRleCArIDEpXHJcbiAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8g4p2MIFNraXAgdGhpcyBjb25uZWN0aW9uIOKAlCB0b28gY2xvc2UgdG8gbGFzdFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgeyByb3c6IHByLCBjb2w6IHBjIH0gPSBwcmV2UGxhY2VkLnN0YXJ0O1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBuZXdSb3csIG5ld0NvbCwgZGlyZWN0aW9uO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChwcmV2UGxhY2VkLmRpcmVjdGlvbiA9PT0gXCJhY3Jvc3NcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOKGlSBJZiBwcmV2aW91cyB3YXMgYWNyb3NzLCBjdXJyZW50IGdvZXMgZG93blxyXG4gICAgICAgICAgICAgICAgICAgIG5ld1JvdyA9IHByIC0gY29ubi50b0luZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbCA9IHBjICsgY29ubi5mcm9tSW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gXCJkb3duXCI7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOKGlCBJZiBwcmV2aW91cyB3YXMgZG93biwgY3VycmVudCBnb2VzIGFjcm9zc1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1JvdyA9IHByICsgY29ubi5mcm9tSW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29sID0gcGMgLSBjb25uLnRvSW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gXCJhY3Jvc3NcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgZml0cyA9IHRydWU7IC8vIPCfn6IgQXNzdW1lIHRoZSB3b3JkIGZpdHMgdW5sZXNzIHByb3ZlbiBvdGhlcndpc2VcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgd29yZC5sZW5ndGg7IGsrKykgeyAvLyDwn5SBIExvb3AgdGhyb3VnaCBlYWNoIGNoYXJhY3RlciBpbiB0aGUgd29yZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIPCfp64gQ29tcHV0ZSB0aGUgcm93IGFuZCBjb2x1bW4gd2hlcmUgdGhpcyBjaGFyYWN0ZXIgd2lsbCBnb1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBkaXJlY3Rpb24gPT09IFwiYWNyb3NzXCIgPyBuZXdSb3cgOiBuZXdSb3cgKyBrOyAvLyBJZiBhY3Jvc3MsIHN0YXkgb24gc2FtZSByb3c7IGlmIGRvd24sIG1vdmUgdmVydGljYWxseVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBkaXJlY3Rpb24gPT09IFwiYWNyb3NzXCIgPyBuZXdDb2wgKyBrIDogbmV3Q29sOyAvLyBJZiBhY3Jvc3MsIG1vdmUgaG9yaXpvbnRhbGx5OyBpZiBkb3duLCBzdGF5IGluIHNhbWUgY29sdW1uXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIPCfmqsgQ2hlY2sgaWYgdGhlIHBvc2l0aW9uIGlzIG91dCBvZiBib3VuZHNcclxuICAgICAgICAgICAgICAgICAgICBpZiAociA8IDAgfHwgciA+PSBncmlkU2l6ZSB8fCBjIDwgMCB8fCBjID49IGdyaWRTaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpdHMgPSBmYWxzZTsgLy8g4p2MIE1hcmsgYXMgaW52YWxpZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgICAgICAgIC8vIOKblCBFeGl0IHRoZSBsb29wIGVhcmx5XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjZWxsID0gZ3JpZFtyXVtjXTsgLy8g8J+TpiBHZXQgdGhlIGN1cnJlbnQgY2VsbCBmcm9tIHRoZSBncmlkXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIPCfmqsgQ2hlY2sgZm9yIGxldHRlciBjb25mbGljdDogY2VsbCBpcyBmaWxsZWQgd2l0aCBhIGRpZmZlcmVudCBsZXR0ZXJcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbCAmJiBjZWxsICE9PSB3b3JkW2tdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpdHMgPSBmYWxzZTsgLy8g4p2MIE1hcmsgYXMgaW52YWxpZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgICAgICAgIC8vIOKblCBFeGl0IHRoZSBsb29wIGVhcmx5XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWZpdHMpIGNvbnRpbnVlOyAvLyDinYwgVHJ5IG5leHQgY29ubmVjdGlvblxyXG5cclxuICAgICAgICAgICAgICAgIC8vLyDwn6exIENoZWNrIHRoZSBjZWxsIGJlZm9yZSB0aGUgZmlyc3QgbGV0dGVyIGFuZCBhZnRlciB0aGUgbGFzdCBsZXR0ZXJcclxuICAgICAgICAgICAgICAgIGxldCBlbmRTYWZlID0gdHJ1ZTsgLy8g4pyFIENoZWNrIGlmIGVuZHMgYXJlIGNsZWFyXHJcbiAgICAgICAgICAgICAgICBsZXQgc2lkZVNhZmUgPSB0cnVlOyAvLyDinIUgQ2hlY2sgaWYgc2lkZSBuZWlnaGJvcnMgb2YgZmlyc3QgJiBsYXN0IGxldHRlcnMgYXJlIGNsZWFyXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJhY3Jvc3NcIikgeyAvLyDihpQgV29yZCBpcyBwbGFjZWQgaG9yaXpvbnRhbGx5XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmVmb3JlID0gZ3JpZFtuZXdSb3ddPy5bbmV3Q29sIC0gMV07IC8vIOKshe+4jyBMZWZ0IG9mIGZpcnN0IGxldHRlclxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFmdGVyID0gZ3JpZFtuZXdSb3ddPy5bbmV3Q29sICsgd29yZC5sZW5ndGhdOyAvLyDinqHvuI8gUmlnaHQgb2YgbGFzdCBsZXR0ZXJcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKGJlZm9yZSAmJiBiZWZvcmUgIT09IG51bGwpIHx8IChhZnRlciAmJiBhZnRlciAhPT0gbnVsbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kU2FmZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8g8J+UjSBDaGVjayB1cC9kb3duIG9mIGZpcnN0IGxldHRlciAob25seSBpZiBub3QgY29ubmVjdGlvbiBwb2ludClcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29ubi50b0luZGV4ICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVwID0gZ3JpZFtuZXdSb3cgLSAxXT8uW25ld0NvbF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRvd24gPSBncmlkW25ld1JvdyArIDFdPy5bbmV3Q29sXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh1cCAmJiB1cCAhPT0gbnVsbCkgfHwgKGRvd24gJiYgZG93biAhPT0gbnVsbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZGVTYWZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIPCflI0gQ2hlY2sgdXAvZG93biBvZiBsYXN0IGxldHRlciAob25seSBpZiBub3QgY29ubmVjdGlvbiBwb2ludClcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0Q29sID0gbmV3Q29sICsgd29yZC5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25uLnRvSW5kZXggIT09IHdvcmQubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1cCA9IGdyaWRbbmV3Um93IC0gMV0/LltsYXN0Q29sXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZG93biA9IGdyaWRbbmV3Um93ICsgMV0/LltsYXN0Q29sXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh1cCAmJiB1cCAhPT0gbnVsbCkgfHwgKGRvd24gJiYgZG93biAhPT0gbnVsbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZGVTYWZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g8J+UgSBDaGVjayB1cC9kb3duIDEgYmxvY2sgZm9yIGFsbCBub24tY29ubmVjdGluZyBsZXR0ZXJzIChtaWRkbGUgbGV0dGVycylcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHdvcmQubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGsgPT09IGNvbm4udG9JbmRleCkgY29udGludWU7IC8vIPCfmqsgU2tpcCBjb25uZWN0aW9uIGxldHRlclxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgciA9IG5ld1JvdztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYyA9IG5ld0NvbCArIGs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1cCA9IGdyaWRbciAtIDFdPy5bY107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRvd24gPSBncmlkW3IgKyAxXT8uW2NdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh1cCAmJiB1cCAhPT0gbnVsbCkgfHwgKGRvd24gJiYgZG93biAhPT0gbnVsbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZGVTYWZlID0gZmFsc2U7IC8vIOKdjCBMZXR0ZXIgaGFzIG5laWdoYm9ycyBhYm92ZS9iZWxvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIOKGlSBXb3JkIGlzIHBsYWNlZCB2ZXJ0aWNhbGx5XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmVmb3JlID0gZ3JpZFtuZXdSb3cgLSAxXT8uW25ld0NvbF07IC8vIOKshu+4jyBBYm92ZSBmaXJzdCBsZXR0ZXJcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhZnRlciA9IGdyaWRbbmV3Um93ICsgd29yZC5sZW5ndGhdPy5bbmV3Q29sXTsgLy8g4qyH77iPIEJlbG93IGxhc3QgbGV0dGVyXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChiZWZvcmUgJiYgYmVmb3JlICE9PSBudWxsKSB8fCAoYWZ0ZXIgJiYgYWZ0ZXIgIT09IG51bGwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZFNhZmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIPCflI0gQ2hlY2sgbGVmdC9yaWdodCBvZiBmaXJzdCBsZXR0ZXIgKG9ubHkgaWYgbm90IGNvbm5lY3Rpb24gcG9pbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbm4udG9JbmRleCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsZWZ0ID0gZ3JpZFtuZXdSb3ddPy5bbmV3Q29sIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gZ3JpZFtuZXdSb3ddPy5bbmV3Q29sICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgobGVmdCAmJiBsZWZ0ICE9PSBudWxsKSB8fCAocmlnaHQgJiYgcmlnaHQgIT09IG51bGwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWRlU2FmZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyDwn5SNIENoZWNrIGxlZnQvcmlnaHQgb2YgbGFzdCBsZXR0ZXIgKG9ubHkgaWYgbm90IGNvbm5lY3Rpb24gcG9pbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdFJvdyA9IG5ld1JvdyArIHdvcmQubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29ubi50b0luZGV4ICE9PSB3b3JkLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVmdCA9IGdyaWRbbGFzdFJvd10/LltuZXdDb2wgLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBncmlkW2xhc3RSb3ddPy5bbmV3Q29sICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgobGVmdCAmJiBsZWZ0ICE9PSBudWxsKSB8fCAocmlnaHQgJiYgcmlnaHQgIT09IG51bGwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWRlU2FmZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIPCflIEgQ2hlY2sgbGVmdC9yaWdodCAxIGJsb2NrIGZvciBhbGwgbm9uLWNvbm5lY3RpbmcgbGV0dGVycyAobWlkZGxlIGxldHRlcnMpXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCB3b3JkLmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrID09PSBjb25uLnRvSW5kZXgpIGNvbnRpbnVlOyAvLyDwn5qrIFNraXAgY29ubmVjdGlvbiBsZXR0ZXJcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBuZXdSb3cgKyBrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjID0gbmV3Q29sO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVmdCA9IGdyaWRbcl0/LltjIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gZ3JpZFtyXT8uW2MgKyAxXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgobGVmdCAmJiBsZWZ0ICE9PSBudWxsKSB8fCAocmlnaHQgJiYgcmlnaHQgIT09IG51bGwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWRlU2FmZSA9IGZhbHNlOyAvLyDinYwgTGV0dGVyIGhhcyBuZWlnaGJvcnMgbGVmdC9yaWdodFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIPCfmqsgU2tpcCB0aGlzIGNvbm5lY3Rpb24gaWYgdGhlIGVuZHMgb3Igc2lkZXMgYXJlbid0IHNhZmVcclxuICAgICAgICAgICAgICAgIGlmICghZW5kU2FmZSB8fCAhc2lkZVNhZmUpIGNvbnRpbnVlO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvLyDinIUgQWxsIGNoZWNrcyBwYXNzZWQg4oCTIG5vdyBwbGFjZSB0aGUgd29yZCBvbiB0aGUgZ3JpZFxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCB3b3JkLmxlbmd0aDsgaysrKSB7IC8vIPCflIEgTG9vcCB0aHJvdWdoIGVhY2ggbGV0dGVyIGFnYWluIHRvIHdyaXRlIGl0IHRvIHRoZSBncmlkXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgciA9IGRpcmVjdGlvbiA9PT0gXCJhY3Jvc3NcIiA/IG5ld1JvdyA6IG5ld1JvdyArIGs7IC8vIPCfp64gQ2FsY3VsYXRlIHJvd1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBkaXJlY3Rpb24gPT09IFwiYWNyb3NzXCIgPyBuZXdDb2wgKyBrIDogbmV3Q29sOyAvLyDwn6euIENhbGN1bGF0ZSBjb2x1bW5cclxuICAgICAgICAgICAgICAgICAgICBncmlkW3JdW2NdID0gd29yZFtrXTsgLy8g4pyN77iPIFdyaXRlIHRoZSBjaGFyYWN0ZXIgdG8gdGhlIGdyaWRcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyDwn5SNIEZpbmQgdGhlIG9yaWdpbmFsIGluZGV4IG9mIHRoaXMgd29yZCBmcm9tIHFuYUxpc3RcclxuICAgICAgICAgICAgICAgIGxldCBmb3VuZEluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHFuYUxpc3QubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocW5hTGlzdFtrXS5hbnN3ZXIudG9VcHBlckNhc2UoKSA9PT0gd29yZCAmJiAhdXNlZEFuc3dlckluZGljZXMuaGFzKGspKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kSW5kZXggPSBrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VkQW5zd2VySW5kaWNlcy5hZGQoayk7IC8vIOKchSBNYXJrIGFzIHVzZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgY29udGludWU7IC8vIPCflIQgU2tpcCBpZiB0aGUgd29yZCBpc24ndCBmb3VuZCBpbiB0aGUgb3JpZ2luYWwgbGlzdFxyXG5cclxuICAgICAgICAgICAgICAgIC8vIPCfk50gU2F2ZSB0aGUgd29yZCdzIHBsYWNlbWVudCBpbmZvIGZvciByZW5kZXJpbmcgb3IgZXhwb3J0aW5nIGxhdGVyXHJcbiAgICAgICAgICAgICAgICBwbGFjZWRXb3Jkcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICB3b3JkLCAgICAgICAgICAgICAgICAgICAvLyBUaGUgd29yZCBiZWluZyBwbGFjZWQgbm93XHJcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uLCAgICAgICAgICAgICAgLy8gYWNyb3NzIG9yIGRvd25cclxuICAgICAgICAgICAgICAgICAgICBzdGFydDogeyByb3c6IG5ld1JvdywgY29sOiBuZXdDb2wgfSxcclxuICAgICAgICAgICAgICAgICAgICBpbmRleDogZm91bmRJbmRleCwgICAgICAvLyBJbmRleCBpbiB0aGUgcW5hTGlzdFxyXG4gICAgICAgICAgICAgICAgICAgIG11dGF0aW9uSW5kZXg6IGksXHJcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGVkRnJvbTogY29ubi5mcm9tLCAgICAgIC8vIOKGkCBwcmV2aW91cyB3b3JkIGl0J3MgY29ubmVjdGVkIGZyb21cclxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0ZWRUbzogY29ubi50bywgICAgICAgICAgLy8g4oaQIHRoaXMgd29yZCAob3B0aW9uYWw7IHNhbWUgYXMgYHdvcmRgKVxyXG4gICAgICAgICAgICAgICAgICAgIGZyb21JbmRleDogY29ubi5mcm9tSW5kZXgsICAgICAvLyDihpAgaW5kZXggaW4gcHJldmlvdXMgd29yZFxyXG4gICAgICAgICAgICAgICAgICAgIHRvSW5kZXg6IGNvbm4udG9JbmRleCwgICAgICAgICAvLyDihpAgaW5kZXggaW4gY3VycmVudCB3b3JkXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBwbGFjZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIOKchSBEb25lIHdpdGggdGhpcyB3b3JkXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghcGxhY2VkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmYWxsYmFja1dvcmQgPSB3b3JkO1xyXG4gICAgICAgICAgICAgICAgaGFzRmFsbGJhY2sgPSB0cnVlO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCB1c2VkU2hhcGUgPSBnZXRVc2VkU2l6ZShncmlkKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbnMgPSB1c2VkU2hhcGUucm93cyA+PSB1c2VkU2hhcGUuY29scyA/IFtcImRvd25cIl0gOiBbXCJhY3Jvc3NcIl07XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBkaXJlY3Rpb24gb2YgZGlyZWN0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNlbnRlclJvdyA9IE1hdGguZmxvb3IoZ3JpZFNpemUgLyAyKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjZW50ZXJDb2wgPSBNYXRoLmZsb29yKGdyaWRTaXplIC8gMik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvd09mZnNldHMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBncmlkU2l6ZSB9LCAoXywgaSkgPT4gaSAtIGNlbnRlclJvdykuc29ydCgoYSwgYikgPT4gTWF0aC5hYnMoYSkgLSBNYXRoLmFicyhiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sT2Zmc2V0cyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IGdyaWRTaXplIH0sIChfLCBpKSA9PiBpIC0gY2VudGVyQ29sKS5zb3J0KChhLCBiKSA9PiBNYXRoLmFicyhhKSAtIE1hdGguYWJzKGIpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBkciBvZiByb3dPZmZzZXRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvdyA9IGNlbnRlclJvdyArIGRyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93IDwgMCB8fCByb3cgPj0gZ3JpZFNpemUpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBkYyBvZiBjb2xPZmZzZXRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2wgPSBjZW50ZXJDb2wgKyBkYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2wgPCAwIHx8IGNvbCA+PSBncmlkU2l6ZSkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZpdHMgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgZmFsbGJhY2tXb3JkLmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgciA9IGRpcmVjdGlvbiA9PT0gXCJhY3Jvc3NcIiA/IHJvdyA6IHJvdyArIGs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYyA9IGRpcmVjdGlvbiA9PT0gXCJhY3Jvc3NcIiA/IGNvbCArIGsgOiBjb2w7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyIDwgMCB8fCByID49IGdyaWRTaXplIHx8IGMgPCAwIHx8IGMgPj0gZ3JpZFNpemUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZml0cyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChncmlkW3JdW2NdICYmIGdyaWRbcl1bY10gIT09IGZhbGxiYWNrV29yZFtrXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXRzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmVpZ2hib3JzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbciAtIDEsIGNdLCBbciArIDEsIGNdLCBbciwgYyAtIDFdLCBbciwgYyArIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbciAtIDEsIGMgLSAxXSwgW3IgLSAxLCBjICsgMV0sIFtyICsgMSwgYyAtIDFdLCBbciArIDEsIGMgKyAxXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbbnIsIG5jXSBvZiBuZWlnaGJvcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnIgPj0gMCAmJiBuciA8IGdyaWRTaXplICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYyA+PSAwICYmIG5jIDwgZ3JpZFNpemUgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRbbnJdW25jXSAmJiBncmlkW25yXVtuY10gIT09IGZhbGxiYWNrV29yZFtrXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpdHMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZpdHMpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJlZm9yZVIgPSBkaXJlY3Rpb24gPT09IFwiYWNyb3NzXCIgPyByb3cgOiByb3cgLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmVmb3JlQyA9IGRpcmVjdGlvbiA9PT0gXCJhY3Jvc3NcIiA/IGNvbCAtIDEgOiBjb2w7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhZnRlclIgPSBkaXJlY3Rpb24gPT09IFwiYWNyb3NzXCIgPyByb3cgOiByb3cgKyBmYWxsYmFja1dvcmQubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWZ0ZXJDID0gZGlyZWN0aW9uID09PSBcImFjcm9zc1wiID8gY29sICsgZmFsbGJhY2tXb3JkLmxlbmd0aCA6IGNvbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ3JpZFtiZWZvcmVSXT8uW2JlZm9yZUNdIHx8IGdyaWRbYWZ0ZXJSXT8uW2FmdGVyQ10pIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaXRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBsYWNlZCA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGZhbGxiYWNrV29yZC5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByID0gZGlyZWN0aW9uID09PSBcImFjcm9zc1wiID8gcm93IDogcm93ICsgaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYyA9IGRpcmVjdGlvbiA9PT0gXCJhY3Jvc3NcIiA/IGNvbCArIGsgOiBjb2w7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRbcl1bY10gPSBmYWxsYmFja1dvcmRba107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmRJbmRleCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgcW5hTGlzdC5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxbmFMaXN0W2tdLmFuc3dlci50b1VwcGVyQ2FzZSgpID09PSBmYWxsYmFja1dvcmQgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICF1c2VkQW5zd2VySW5kaWNlcy5oYXMoaylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZEluZGV4ID0gaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWRBbnN3ZXJJbmRpY2VzLmFkZChrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWRXb3Jkcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd29yZDogZmFsbGJhY2tXb3JkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB7IHJvdywgY29sIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBmb3VuZEluZGV4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbkluZGV4OiBpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0ZWRGcm9tOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0ZWRUbzogZmFsbGJhY2tXb3JkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tSW5kZXg6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvSW5kZXg6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGxhY2VkKSBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIXBsYWNlZCkgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFwbGFjZWQpIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyDinIUgUmV0dXJuIHRoZSBidWlsdCBncmlkIGFuZCB3b3JkIHBsYWNlbWVudCBpbmZvXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZ3JpZCxcclxuICAgICAgICAgICAgcGxhY2VkV29yZHM6IHBsYWNlZFNvRmFyLmNvbmNhdChwbGFjZWRXb3JkcyksXHJcbiAgICAgICAgICAgIGhhc0ZhbGxiYWNrLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgLy8g8J+UgSBHZW5lcmF0ZSBtdXRhdGlvbnMgZm9yIGVhY2ggY2x1c3RlclxyXG4gICAgY29uc3QgY2x1c3Rlck11dGF0aW9ucyA9IGNsdXN0ZXJzLm1hcChjbHVzdGVyID0+IHtcclxuICAgICAgICBjb25zdCBjbHVzdGVyV29yZHMgPSBjbHVzdGVyO1xyXG4gICAgICAgIGNvbnN0IGNsdXN0ZXJDb25ucyA9IGFsbENvbm5lY3Rpb25zLmZpbHRlcihjID0+IGNsdXN0ZXJXb3Jkcy5pbmNsdWRlcyhjLmZyb20pICYmIGNsdXN0ZXJXb3Jkcy5pbmNsdWRlcyhjLnRvKSk7XHJcbiAgICAgICAgY29uc3QgbXV0YXRpb25zID0gZ2VuZXJhdGVNdXRhdGlvbnNGcm9tQ29ubmVjdGlvbnMoY2x1c3RlcldvcmRzLCBjbHVzdGVyQ29ubnMpO1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjbHVzdGVyLFxyXG4gICAgICAgICAgICBtdXRhdGlvbnNcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFVzZWRTaXplKGdyaWQpIHtcclxuICAgICAgICBsZXQgdG9wID0gZ3JpZC5sZW5ndGgsIGJvdHRvbSA9IDAsIGxlZnQgPSBncmlkWzBdLmxlbmd0aCwgcmlnaHQgPSAwO1xyXG4gICAgICAgIGZvciAobGV0IHIgPSAwOyByIDwgZ3JpZC5sZW5ndGg7IHIrKykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGdyaWRbMF0ubGVuZ3RoOyBjKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChncmlkW3JdW2NdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9wID0gTWF0aC5taW4odG9wLCByKTtcclxuICAgICAgICAgICAgICAgICAgICBib3R0b20gPSBNYXRoLm1heChib3R0b20sIHIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBNYXRoLm1pbihsZWZ0LCBjKTtcclxuICAgICAgICAgICAgICAgICAgICByaWdodCA9IE1hdGgubWF4KHJpZ2h0LCBjKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyByb3dzOiBib3R0b20gLSB0b3AgKyAxLCBjb2xzOiByaWdodCAtIGxlZnQgKyAxIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0TmV4dENsdXN0ZXJPZmZzZXQoZ3JpZCkge1xyXG4gICAgICAgIGxldCBtYXhSb3cgPSAwO1xyXG4gICAgICAgIGZvciAobGV0IHIgPSAwOyByIDwgZ3JpZC5sZW5ndGg7IHIrKykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGdyaWRbMF0ubGVuZ3RoOyBjKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChncmlkW3JdW2NdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4Um93ID0gTWF0aC5tYXgobWF4Um93LCByKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTdGFydCBuZXcgY2x1c3RlciAzIHJvd3MgYmVsb3cgdGhlIGxhc3QgdXNlZCByb3dcclxuICAgICAgICByZXR1cm4geyByb3c6IG1heFJvdyArIDMsIGNvbDogTWF0aC5mbG9vcihncmlkWzBdLmxlbmd0aCAvIDIpIH07XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICAvLyDwn5SBIExvb3AgdGhyb3VnaCBhbGwgY2x1c3RlcnMnIGdlbmVyYXRlZCBtdXRhdGlvbnNcclxuICAgIGxldCBjb21iaW5lZEdyaWQgPSBudWxsO1xyXG4gICAgbGV0IHBsYWNlZFNvRmFyID0gW107XHJcblxyXG4gICAgZm9yIChjb25zdCB7IGNsdXN0ZXIsIG11dGF0aW9ucyB9IG9mIGNsdXN0ZXJNdXRhdGlvbnMpIHtcclxuICAgICAgICBsZXQgYmVzdElzUGVyZmVjdCA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBiZXN0UGVyZmVjdCA9IG51bGw7XHJcbiAgICAgICAgY29uc3QgY2x1c3RlckNvbm5lY3Rpb25zID0gYWxsQ29ubmVjdGlvbnMuZmlsdGVyKFxyXG4gICAgICAgICAgICBjID0+IGNsdXN0ZXIuaW5jbHVkZXMoYy5mcm9tKSAmJiBjbHVzdGVyLmluY2x1ZGVzKGMudG8pXHJcbiAgICAgICAgKTtcclxuICAgICAgICBsZXQgYmVzdEZvckNsdXN0ZXIgPSBudWxsO1xyXG4gICAgICAgIGxldCBiZXN0QXJlYSA9IEluZmluaXR5O1xyXG4gICAgICAgIGxldCBhdHRlbXB0cyA9IDA7XHJcbiAgICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbnMpIHtcclxuICAgICAgICAgICAgaWYgKGF0dGVtcHRzKysgPiAxMDAwMCkgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgb2Zmc2V0OiBjZW50ZXIgZm9yIGZpcnN0IGNsdXN0ZXIsIG9mZnNldCBmb3IgbmV4dCBjbHVzdGVyc1xyXG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBjb21iaW5lZEdyaWQgPyBnZXROZXh0Q2x1c3Rlck9mZnNldChjb21iaW5lZEdyaWQpIDogbnVsbDtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcGxhY2VNdXRhdGlvblRvR3JpZChcclxuICAgICAgICAgICAgICAgIG11dGF0aW9uLFxyXG4gICAgICAgICAgICAgICAgY2x1c3RlckNvbm5lY3Rpb25zLFxyXG4gICAgICAgICAgICAgICAgZ3JpZFNpemUsXHJcbiAgICAgICAgICAgICAgICBjb21iaW5lZEdyaWQsXHJcbiAgICAgICAgICAgICAgICBvZmZzZXQsXHJcbiAgICAgICAgICAgICAgICBwbGFjZWRTb0ZhclxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkgY29udGludWU7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgZ3JpZCwgcGxhY2VkV29yZHMsIGhhc0ZhbGxiYWNrIH0gPSByZXN1bHQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzUGVyZmVjdCA9ICFoYXNGYWxsYmFjaztcclxuICAgICAgICAgICAgY29uc3QgdXNlZCA9IGdldFVzZWRTaXplKGdyaWQpO1xyXG4gICAgICAgICAgICBjb25zdCBhcmVhID0gdXNlZC5yb3dzICogdXNlZC5jb2xzO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFiZXN0Rm9yQ2x1c3Rlcikge1xyXG4gICAgICAgICAgICAgICAgYmVzdEZvckNsdXN0ZXIgPSB7IGdyaWQsIHBsYWNlZFdvcmRzIH07XHJcbiAgICAgICAgICAgICAgICBiZXN0QXJlYSA9IGFyZWE7XHJcbiAgICAgICAgICAgICAgICBiZXN0SXNQZXJmZWN0ID0gaXNQZXJmZWN0O1xyXG4gICAgICAgICAgICAgICAgYmVzdFBlcmZlY3QgPSBpc1BlcmZlY3QgPyB7IGdyaWQsIHBsYWNlZFdvcmRzLCBhcmVhIH0gOiBudWxsO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaXNTbWFsbGVyRW5vdWdoVGhhblBlcmZlY3QgPSBiZXN0UGVyZmVjdCAmJiBhcmVhIDwgYmVzdFBlcmZlY3QuYXJlYSAtIDQ5OyAvLyA3eDcgPSA0OVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpc1BlcmZlY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWJlc3RJc1BlcmZlY3QgfHwgYXJlYSA8IGJlc3RQZXJmZWN0LmFyZWEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdFBlcmZlY3QgPSB7IGdyaWQsIHBsYWNlZFdvcmRzLCBhcmVhIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RGb3JDbHVzdGVyID0geyBncmlkLCBwbGFjZWRXb3JkcyB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0QXJlYSA9IGFyZWE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RJc1BlcmZlY3QgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWJlc3RJc1BlcmZlY3QgfHwgaXNTbWFsbGVyRW5vdWdoVGhhblBlcmZlY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBiZXN0Rm9yQ2x1c3RlciA9IHsgZ3JpZCwgcGxhY2VkV29yZHMgfTtcclxuICAgICAgICAgICAgICAgICAgICBiZXN0QXJlYSA9IGFyZWE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYmVzdEZvckNsdXN0ZXIpIHtcclxuICAgICAgICAgICAgY29tYmluZWRHcmlkID0gYmVzdEZvckNsdXN0ZXIuZ3JpZDtcclxuICAgICAgICAgICAgcGxhY2VkU29GYXIgPSBiZXN0Rm9yQ2x1c3Rlci5wbGFjZWRXb3JkcztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYXNzaWduQ2x1ZU51bWJlcnMocGxhY2VkV29yZHMpIHtcclxuICAgICAgICBjb25zdCBjbHVlTWFwID0gbmV3IE1hcCgpOyAvLyDwn5SQIFByZXZlbnQgZHVwbGljYXRlIGNsdWUgbnVtYmVyc1xyXG4gICAgICAgIGxldCBuZXh0ID0gMTtcclxuICAgICAgICBmb3IgKGNvbnN0IHdvcmQgb2YgcGxhY2VkV29yZHMpIHtcclxuICAgICAgICAgICAgY29uc3Qga2V5ID0gYCR7d29yZC5zdGFydC5yb3d9LCR7d29yZC5zdGFydC5jb2x9YDsgLy8g8J+TjSBJZGVudGlmeSBzdGFydCBjZWxsXHJcblxyXG4gICAgICAgICAgICBpZiAoIWNsdWVNYXAuaGFzKGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGNsdWVNYXAuc2V0KGtleSwgbmV4dCsrKTsgLy8g8J+GlSBGaXJzdCB0aW1lIHdlIHNlZSB0aGlzIHN0YXJ0IGNlbGxcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgd29yZC5jbHVlTnVtYmVyID0gY2x1ZU1hcC5nZXQoa2V5KTsgLy8g8J+noCBTaGFyZSBudW1iZXIgZm9yIHNhbWUgY2VsbFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyDinIUgU2tpcCBldmVyeXRoaW5nIGlmIG5vIGlucHV0LCBwcmV2ZW50IGNyYXNoIGF0IHRoZSBiZWdpbm5pbmcgXHJcbiAgICBpZiAocW5hTGlzdC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBncmlkOiBbXSwgcGxhY2VkV29yZHM6IFtdIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gYXNzaWduQ2x1ZU51bWJlcnMocGxhY2VkU29GYXIpO1xyXG4gICAgLy8g8J+UjSBGaWx0ZXIgb3V0IGJyb2tlbiBwbGFjZW1lbnRzXHJcbiAgICBjb25zdCBjbGVhbmVkUGxhY2VkV29yZHMgPSBwbGFjZWRTb0Zhci5maWx0ZXIodyA9PiB3LnN0YXJ0ICYmIHcuZGlyZWN0aW9uICYmIHR5cGVvZiB3LmluZGV4ID09PSBcIm51bWJlclwiKTtcclxuICAgIGFzc2lnbkNsdWVOdW1iZXJzKGNsZWFuZWRQbGFjZWRXb3Jkcyk7XHJcbiAgICAvLyDwn5KhIEFkZCB0aGlzOiByZWNvbnN0cnVjdCB0aGUgYW5zd2VyIGZvciBlYWNoIHBsYWNlZCB3b3JkXHJcbiAgICBmb3IgKGNvbnN0IHdvcmQgb2YgY2xlYW5lZFBsYWNlZFdvcmRzKSB7XHJcbiAgICAgICAgaWYgKCF3b3JkLmFuc3dlcikge1xyXG4gICAgICAgICAgICB3b3JkLmFuc3dlciA9IHFuYUxpc3Rbd29yZC5pbmRleF0/LmFuc3dlcj8udG9VcHBlckNhc2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcclxuICAgICAgICBncmlkOiBjb21iaW5lZEdyaWQgfHwgW10sXHJcbiAgICAgICAgcGxhY2VkV29yZHM6IGNsZWFuZWRQbGFjZWRXb3JkcyxcclxuICAgIH0pO1xyXG5cclxufVxyXG4iXSwibmFtZXMiOlsiTmV4dFJlc3BvbnNlIiwiUE9TVCIsInJlcSIsInFuYUxpc3QiLCJqc29uIiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwiZ3JpZCIsInBsYWNlZFdvcmRzIiwic3RhdHVzIiwid29yZHMiLCJtYXAiLCJxIiwiYW5zd2VyIiwidG9VcHBlckNhc2UiLCJidWlsZEluZGV4ZWRMZXR0ZXJNYXAiLCJ3b3JkIiwiaSIsImxldHRlciIsInB1c2giLCJpbmRleCIsImdlbmVyYXRlSW5kZXhlZENvbm5lY3Rpb25zIiwiaW5kZXhlZExldHRlck1hcCIsImNvbm5lY3Rpb25zIiwiZW50cmllcyIsIk9iamVjdCIsImoiLCJmcm9tIiwidG8iLCJ2aWEiLCJmcm9tSW5kZXgiLCJ0b0luZGV4IiwiY2x1c3RlcldvcmRzRnJvbUNvbm5lY3Rpb25zIiwiZ3JhcGgiLCJTZXQiLCJjb25uIiwiYWRkIiwidmlzaXRlZCIsImNsdXN0ZXJzIiwiaGFzIiwiY2x1c3RlciIsInF1ZXVlIiwiY3VycmVudCIsInBvcCIsIm5laWdoYm9yIiwibG9uZ2VzdFdvcmRMZW5ndGgiLCJNYXRoIiwibWF4IiwiaXRlbSIsImdyaWRTaXplIiwiYWxsQ29ubmVjdGlvbnMiLCJnZW5lcmF0ZU11dGF0aW9uc0Zyb21Db25uZWN0aW9ucyIsIm11dGF0aW9ucyIsIk1BWF9NVVRBVElPTlMiLCJkZnMiLCJwYXRoIiwidXNlZCIsInZpc2l0ZWRTZXQiLCJsYXN0V29yZCIsImluY2x1ZGVzIiwiZGVsZXRlIiwic3RhcnRXb3JkIiwicGxhY2VNdXRhdGlvblRvR3JpZCIsIm11dGF0aW9uIiwiZXhpc3RpbmdHcmlkIiwib2Zmc2V0IiwicGxhY2VkU29GYXIiLCJyb3ciLCJmaWxsIiwidXNlZEFuc3dlckluZGljZXMiLCJoYXNGYWxsYmFjayIsInN0YXJ0Um93IiwiZmxvb3IiLCJzdGFydENvbCIsImNvbCIsImZpcnN0SW5kZXgiLCJrIiwiZGlyZWN0aW9uIiwic3RhcnQiLCJwcmV2IiwiY2FuZGlkYXRlQ29ubnMiLCJmaWx0ZXIiLCJjIiwicGxhY2VkIiwicHJldlBsYWNlZCIsImZpbmQiLCJwIiwic29tZSIsImxhc3RQbGFjZWQiLCJsYXN0VG9JbmRleCIsInVuZGVmaW5lZCIsInByIiwicGMiLCJuZXdSb3ciLCJuZXdDb2wiLCJmaXRzIiwiciIsImNlbGwiLCJlbmRTYWZlIiwic2lkZVNhZmUiLCJiZWZvcmUiLCJhZnRlciIsInVwIiwiZG93biIsImxhc3RDb2wiLCJsZWZ0IiwicmlnaHQiLCJsYXN0Um93IiwiZm91bmRJbmRleCIsIm11dGF0aW9uSW5kZXgiLCJjb25uZWN0ZWRGcm9tIiwiY29ubmVjdGVkVG8iLCJmYWxsYmFja1dvcmQiLCJ1c2VkU2hhcGUiLCJnZXRVc2VkU2l6ZSIsImRpcmVjdGlvbnMiLCJyb3dzIiwiY29scyIsImNlbnRlclJvdyIsImNlbnRlckNvbCIsInJvd09mZnNldHMiLCJfIiwic29ydCIsImEiLCJiIiwiYWJzIiwiY29sT2Zmc2V0cyIsImRyIiwiZGMiLCJuZWlnaGJvcnMiLCJuciIsIm5jIiwiYmVmb3JlUiIsImJlZm9yZUMiLCJhZnRlclIiLCJhZnRlckMiLCJjb25jYXQiLCJjbHVzdGVyTXV0YXRpb25zIiwiY2x1c3RlcldvcmRzIiwiY2x1c3RlckNvbm5zIiwidG9wIiwiYm90dG9tIiwibWluIiwiZ2V0TmV4dENsdXN0ZXJPZmZzZXQiLCJtYXhSb3ciLCJjb21iaW5lZEdyaWQiLCJiZXN0SXNQZXJmZWN0IiwiYmVzdFBlcmZlY3QiLCJjbHVzdGVyQ29ubmVjdGlvbnMiLCJiZXN0Rm9yQ2x1c3RlciIsImJlc3RBcmVhIiwiSW5maW5pdHkiLCJhdHRlbXB0cyIsInJlc3VsdCIsImlzUGVyZmVjdCIsImFyZWEiLCJpc1NtYWxsZXJFbm91Z2hUaGFuUGVyZmVjdCIsImFzc2lnbkNsdWVOdW1iZXJzIiwiY2x1ZU1hcCIsIk1hcCIsIm5leHQiLCJrZXkiLCJzZXQiLCJjbHVlTnVtYmVyIiwiZ2V0IiwiY2xlYW5lZFBsYWNlZFdvcmRzIiwidyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./app/api/generate-puzzle/route.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fgenerate-puzzle%2Froute&page=%2Fapi%2Fgenerate-puzzle%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fgenerate-puzzle%2Froute.js&appDir=C%3A%5CUsers%5Canhvo%5CDesktop%5CHippoCampus%5Cfrontend%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Canhvo%5CDesktop%5CHippoCampus%5Cfrontend&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fgenerate-puzzle%2Froute&page=%2Fapi%2Fgenerate-puzzle%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fgenerate-puzzle%2Froute.js&appDir=C%3A%5CUsers%5Canhvo%5CDesktop%5CHippoCampus%5Cfrontend%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Canhvo%5CDesktop%5CHippoCampus%5Cfrontend&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   workAsyncStorage: () => (/* binding */ workAsyncStorage),\n/* harmony export */   workUnitAsyncStorage: () => (/* binding */ workUnitAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/route-kind */ \"(rsc)/./node_modules/next/dist/server/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var C_Users_anhvo_Desktop_HippoCampus_frontend_app_api_generate_puzzle_route_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./app/api/generate-puzzle/route.js */ \"(rsc)/./app/api/generate-puzzle/route.js\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/generate-puzzle/route\",\n        pathname: \"/api/generate-puzzle\",\n        filename: \"route\",\n        bundlePath: \"app/api/generate-puzzle/route\"\n    },\n    resolvedPagePath: \"C:\\\\Users\\\\anhvo\\\\Desktop\\\\HippoCampus\\\\frontend\\\\app\\\\api\\\\generate-puzzle\\\\route.js\",\n    nextConfigOutput,\n    userland: C_Users_anhvo_Desktop_HippoCampus_frontend_app_api_generate_puzzle_route_js__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIvaW5kZXguanM/bmFtZT1hcHAlMkZhcGklMkZnZW5lcmF0ZS1wdXp6bGUlMkZyb3V0ZSZwYWdlPSUyRmFwaSUyRmdlbmVyYXRlLXB1enpsZSUyRnJvdXRlJmFwcFBhdGhzPSZwYWdlUGF0aD1wcml2YXRlLW5leHQtYXBwLWRpciUyRmFwaSUyRmdlbmVyYXRlLXB1enpsZSUyRnJvdXRlLmpzJmFwcERpcj1DJTNBJTVDVXNlcnMlNUNhbmh2byU1Q0Rlc2t0b3AlNUNIaXBwb0NhbXB1cyU1Q2Zyb250ZW5kJTVDYXBwJnBhZ2VFeHRlbnNpb25zPXRzeCZwYWdlRXh0ZW5zaW9ucz10cyZwYWdlRXh0ZW5zaW9ucz1qc3gmcGFnZUV4dGVuc2lvbnM9anMmcm9vdERpcj1DJTNBJTVDVXNlcnMlNUNhbmh2byU1Q0Rlc2t0b3AlNUNIaXBwb0NhbXB1cyU1Q2Zyb250ZW5kJmlzRGV2PXRydWUmdHNjb25maWdQYXRoPXRzY29uZmlnLmpzb24mYmFzZVBhdGg9JmFzc2V0UHJlZml4PSZuZXh0Q29uZmlnT3V0cHV0PSZwcmVmZXJyZWRSZWdpb249Jm1pZGRsZXdhcmVDb25maWc9ZTMwJTNEISIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUErRjtBQUN2QztBQUNxQjtBQUNxQztBQUNsSDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUdBQW1CO0FBQzNDO0FBQ0EsY0FBYyxrRUFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWTtBQUNaLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNEQUFzRDtBQUM5RDtBQUNBLFdBQVcsNEVBQVc7QUFDdEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUMwRjs7QUFFMUYiLCJzb3VyY2VzIjpbIiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcHBSb3V0ZVJvdXRlTW9kdWxlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvcm91dGUtbW9kdWxlcy9hcHAtcm91dGUvbW9kdWxlLmNvbXBpbGVkXCI7XG5pbXBvcnQgeyBSb3V0ZUtpbmQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBwYXRjaEZldGNoIGFzIF9wYXRjaEZldGNoIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvbGliL3BhdGNoLWZldGNoXCI7XG5pbXBvcnQgKiBhcyB1c2VybGFuZCBmcm9tIFwiQzpcXFxcVXNlcnNcXFxcYW5odm9cXFxcRGVza3RvcFxcXFxIaXBwb0NhbXB1c1xcXFxmcm9udGVuZFxcXFxhcHBcXFxcYXBpXFxcXGdlbmVyYXRlLXB1enpsZVxcXFxyb3V0ZS5qc1wiO1xuLy8gV2UgaW5qZWN0IHRoZSBuZXh0Q29uZmlnT3V0cHV0IGhlcmUgc28gdGhhdCB3ZSBjYW4gdXNlIHRoZW0gaW4gdGhlIHJvdXRlXG4vLyBtb2R1bGUuXG5jb25zdCBuZXh0Q29uZmlnT3V0cHV0ID0gXCJcIlxuY29uc3Qgcm91dGVNb2R1bGUgPSBuZXcgQXBwUm91dGVSb3V0ZU1vZHVsZSh7XG4gICAgZGVmaW5pdGlvbjoge1xuICAgICAgICBraW5kOiBSb3V0ZUtpbmQuQVBQX1JPVVRFLFxuICAgICAgICBwYWdlOiBcIi9hcGkvZ2VuZXJhdGUtcHV6emxlL3JvdXRlXCIsXG4gICAgICAgIHBhdGhuYW1lOiBcIi9hcGkvZ2VuZXJhdGUtcHV6emxlXCIsXG4gICAgICAgIGZpbGVuYW1lOiBcInJvdXRlXCIsXG4gICAgICAgIGJ1bmRsZVBhdGg6IFwiYXBwL2FwaS9nZW5lcmF0ZS1wdXp6bGUvcm91dGVcIlxuICAgIH0sXG4gICAgcmVzb2x2ZWRQYWdlUGF0aDogXCJDOlxcXFxVc2Vyc1xcXFxhbmh2b1xcXFxEZXNrdG9wXFxcXEhpcHBvQ2FtcHVzXFxcXGZyb250ZW5kXFxcXGFwcFxcXFxhcGlcXFxcZ2VuZXJhdGUtcHV6emxlXFxcXHJvdXRlLmpzXCIsXG4gICAgbmV4dENvbmZpZ091dHB1dCxcbiAgICB1c2VybGFuZFxufSk7XG4vLyBQdWxsIG91dCB0aGUgZXhwb3J0cyB0aGF0IHdlIG5lZWQgdG8gZXhwb3NlIGZyb20gdGhlIG1vZHVsZS4gVGhpcyBzaG91bGRcbi8vIGJlIGVsaW1pbmF0ZWQgd2hlbiB3ZSd2ZSBtb3ZlZCB0aGUgb3RoZXIgcm91dGVzIHRvIHRoZSBuZXcgZm9ybWF0LiBUaGVzZVxuLy8gYXJlIHVzZWQgdG8gaG9vayBpbnRvIHRoZSByb3V0ZS5cbmNvbnN0IHsgd29ya0FzeW5jU3RvcmFnZSwgd29ya1VuaXRBc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzIH0gPSByb3V0ZU1vZHVsZTtcbmZ1bmN0aW9uIHBhdGNoRmV0Y2goKSB7XG4gICAgcmV0dXJuIF9wYXRjaEZldGNoKHtcbiAgICAgICAgd29ya0FzeW5jU3RvcmFnZSxcbiAgICAgICAgd29ya1VuaXRBc3luY1N0b3JhZ2VcbiAgICB9KTtcbn1cbmV4cG9ydCB7IHJvdXRlTW9kdWxlLCB3b3JrQXN5bmNTdG9yYWdlLCB3b3JrVW5pdEFzeW5jU3RvcmFnZSwgc2VydmVySG9va3MsIHBhdGNoRmV0Y2gsICB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHAtcm91dGUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fgenerate-puzzle%2Froute&page=%2Fapi%2Fgenerate-puzzle%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fgenerate-puzzle%2Froute.js&appDir=C%3A%5CUsers%5Canhvo%5CDesktop%5CHippoCampus%5Cfrontend%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Canhvo%5CDesktop%5CHippoCampus%5Cfrontend&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true!":
/*!******************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true! ***!
  \******************************************************************************************************/
/***/ (() => {



/***/ }),

/***/ "(ssr)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true!":
/*!******************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true! ***!
  \******************************************************************************************************/
/***/ (() => {



/***/ }),

/***/ "../app-render/after-task-async-storage.external":
/*!***********************************************************************************!*\
  !*** external "next/dist/server/app-render/after-task-async-storage.external.js" ***!
  \***********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/after-task-async-storage.external.js");

/***/ }),

/***/ "../app-render/work-async-storage.external":
/*!*****************************************************************************!*\
  !*** external "next/dist/server/app-render/work-async-storage.external.js" ***!
  \*****************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/work-async-storage.external.js");

/***/ }),

/***/ "./work-unit-async-storage.external":
/*!**********************************************************************************!*\
  !*** external "next/dist/server/app-render/work-unit-async-storage.external.js" ***!
  \**********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/work-unit-async-storage.external.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fgenerate-puzzle%2Froute&page=%2Fapi%2Fgenerate-puzzle%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fgenerate-puzzle%2Froute.js&appDir=C%3A%5CUsers%5Canhvo%5CDesktop%5CHippoCampus%5Cfrontend%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Canhvo%5CDesktop%5CHippoCampus%5Cfrontend&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();